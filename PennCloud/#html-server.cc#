#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <ctype.h>
#include <string>
#include <vector>
#include <malloc>
#include <iostream>
#include <map>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <chrono>
#include <regex>
#include "functions.h"
#include "structures.h"

//TODO TO-CHECK should multiple users be able to login from the same browser???

//TO-INTEGRATE
// None is the default username. DB shouldn't be getting none. DB should check this!!

//	Forward Declarations

std::string read(std::string);
std::string read(int);
void write(std::string, std::string);
std::string findGroup(std::string);

//	Structures and data types

struct serverStruct {

	struct sockaddr_in address;
	int socket = -1;
	bool active = false;
};

struct message {

	uint64_t timestamp;
	std::string value;
};

//	Global variables

std::vector<serverStruct> servers;
int W;
int R;
std::vector<message> messages;
std::string config;
serverStruct master_server;

std::map <int, int> servertoload; // mapping from port numbers to individual load
std::map <int, bool> servertoactive; // mapping from port numbers to active state
std::map <int, std::string> servertotablet; // mapping from port numbers to individual tablets

int portNum = 8080;
bool verbose = false;
std::string okHeader("HTTP/1.1 200 OK\r\nServer: 505Team11\r\nContent-Type: text/html\r\nConnection: close\r\n");

//	Functions

void closeConnections() {

	std::string message = "QUIT";
	logSend("%s (%d)", message.c_str(), (int)message.length());

	int length = message.size();

	for (int i = 0; i < servers.size(); i++) {

		write(servers[i].socket, &length, sizeof(length));

		for (int j = 0; j < message.size(); j++) {
			write(servers[i].socket, &message[j], sizeof(message[j]));
		}

		std::string response = read(servers[i].socket);
		logReceive("(%d) %s", ntohs(servers[i].address.sin_port), response.c_str());
	}
}

void establishConnections() {

	//	For all the servers in the list, tries to establish connection and refresh the socket.
	//	If a connection is already established, verifies by sending a NOOP

	for (int i = 0; i < servers.size(); i++) {

		if (servers[i].active == false) {

			int sock = socket(PF_INET, SOCK_STREAM, 0);
			servers[i].socket = sock;

			if(connect(sock, (struct sockaddr*) &servers[i].address, sizeof(servers[i].address)) < 0) {

				logVerbose("Could not establish connection with %d", ntohs(servers[i].address.sin_port));
				servers[i].active = false;
			}
			else {

				servers[i].active = true;
			}
		}
		else {

			std::string message = "NOOP";
			int length = message.size();
			logSend("%s (%d)", message.c_str(), (int)message.length());

			write(servers[i].socket, &length, sizeof(length));

			for (int j = 0; j < message.size(); j++) {
				write(servers[i].socket, &message[j], sizeof(message[j]));
			}

			std::string response;
			response = read(servers[i].socket);

			if (response == "-1") {

				int sock = socket(PF_INET, SOCK_STREAM, 0);
				servers[i].socket = sock;

				if(connect(sock, (struct sockaddr*) &servers[i].address, sizeof(servers[i].address)) < 0) {

					logVerbose("Could not establish connection with %d", ntohs(servers[i].address.sin_port));
					servers[i].active = false;
				}
				else {

					servers[i].active = true;
				}
			}
		}
	}
}

void terminate(int signal) {

//	Executed when client quits (handle CTRL + Q)

	closeConnections();
	panic("Exiting");
}

void bufferMessage(std::string buffer) {

	message current;

	std::stringstream timestamp(buffer.substr(1, buffer.find("]") - 2));
	timestamp >> current.timestamp;
	current.value = buffer.substr(buffer.find("]") + 1, std::string::npos);

	messages.push_back(current);
}

void findMaster() {

	std::ifstream file(config);
	std::string contents;

	if (!file) {
		panic("Error: Could not read file <%s>", config.c_str());
	}

	std::string line;

	while (getline(file, line)) {
		if (line[0] != '#') {
			if (line.find("Master") != std::string::npos)
			{
				serverStruct server;

				bzero(&server.address, sizeof(server.address));
				server.address.sin_family = AF_INET;

				std::stringstream port(line.substr(line.find(':') + 1, line.find(",") - line.find(':') - 1));
				int portNumber = 0;
				port >> portNumber;
				server.address.sin_port = htons(portNumber);

				inet_pton(AF_INET, line.substr(0, line.find(':')).c_str(), &(server.address.sin_addr));

				master_server = server;
			}
		}
	}
}

void parseServerList(std::string group) {

//	Finds server belonging to the given group in storage.md file and stores them in the vector servers

	servers.clear();

	std::ifstream file(config);
	std::string contents;

	if (!file) {
		panic("Error: Could not read file <%s>", config.c_str());
	}

	std::string line;

	while (getline(file, line)) {
		if (line[0] != '#') {

			if (line.substr(line.find("- ") + 2, std::string::npos) == group) {
				serverStruct server;
				bzero(&server.address, sizeof(server.address));
				server.address.sin_family = AF_INET;
				std::stringstream port(line.substr(line.find(':') + 1, line.find(",") - line.find(':') - 1));
				int portNumber = 0;
				port >> portNumber;
				server.address.sin_port = htons(portNumber);
				inet_pton(AF_INET, line.substr(0, line.find(':')).c_str(), &(server.address.sin_addr));
				servers.push_back(server);
			}
		}
	}

	if (servers.size() == 0) {
		panic("No storage servers found for group %s", group.c_str());
	}
}

void initializeQuorum() {

	W = servers.size()/2 + 1;
	R = servers.size() - W + 1;
}

std::string read(int socket) {

//	Read from a particular server

	int length;
	std::string buffer;

	if (read(socket, &length, sizeof(length)) <= 0) {
		return "-1";
	}

	for (int j = 0; j < length; j++) {

		char character;
		read(socket, &character, sizeof(character));
		buffer.push_back(character);
	}

	return buffer;
}

std::string read(std::string row) {

//	Read from all the R servers

	int count = 0;

	for (int i = 0; i < servers.size(); i++) {

	//	Reads a message from the socket

		int length;
		std::string buffer;

		if (read(servers[i].socket, &length, sizeof(length)) <= 0) {
			logVerbose("Could not connect to %d", ntohs(servers[i].address.sin_port));
			servers[i].active = false;
			continue;
		}
		else {
			count++;
		}

		for (int j = 0; j < length; j++) {

			char character;
			read(servers[i].socket, &character, sizeof(character));
			buffer.push_back(character);
		}

		logReceive("(%d) %s (%d)", ntohs(servers[i].address.sin_port), buffer.c_str(), (int)buffer.length());

		bufferMessage(buffer);
	}

	if (count < R) {

		panic("Could only read from %d/%d servers", count, W);
	}

//	Go through all the messages and select the one with highest timestamp

	message final = messages[0];

	for (int i = 1; i < messages.size(); i++) {

		if (messages[i].timestamp > final.timestamp) {

			final = messages[i];
		}
	}

	messages.clear();

	return final.value;
}

void write(std::string message, std::string row) {

	logSend("%s (%d)", message.c_str(), (int)message.length());

	int count = 0;

	for (int i = 0; i < servers.size(); i++) {

		int length = message.size();

		write(servers[i].socket, &length, sizeof(length));

		for (int j = 0; j < message.size(); j++) {
			write(servers[i].socket, &message[j], sizeof(message[j]));
		}

		std::string response;
		response = read(servers[i].socket);

		if (response == "-1") {
			servers[i].active = false;
		}
		else {
			logReceive("(%d) %s", ntohs(servers[i].address.sin_port), response.c_str());
			count++;
		}
	}

	if (count < W) {

		panic("Could only write to %d/%d servers", count, W);
	}
}

std::string findGroup(std::string value) {

	return "G1";

//	Parses server list in the storage.txt configuration file and find master and then ask the master for group

	std::ifstream file(config);
	std::string contents;

	if (!file) {
		panic("An error occurred when reading %s", config.c_str());
	}

	std::string line;
	std::stringstream masterIP;
	std::stringstream masterPort;

	bool masterFound = false;

	while (getline(file, line)) {

		if (line[0] != '#') {

			if (line.substr(line.find(", ") + 2, std::string::npos) == "Master") {

				masterIP << line.substr(0, line.find(":"));
				masterPort << line.substr(line.find(":") + 1, line.find(",") - line.find(":") - 1);

				logVerbose("Master found at %s:%s", masterIP.str().c_str(), masterPort.str().c_str());
				masterFound = true;
				break;
			}
		}
	}

	if (masterFound == false) {
		panic("Master was not found in the configuration file (%s)", config.c_str());
	}

//	Convert the string to the address

	struct sockaddr_in master;
	bzero(&master, sizeof(master));
	master.sin_family = AF_INET;
	int port = 0;
	masterPort >> port;
	master.sin_port = htons(port);
	inet_pton(AF_INET, masterIP.str().c_str(), &(master.sin_addr));

//	Connect to the master via TCP

	int sock = socket(PF_INET, SOCK_STREAM, 0);

	if(connect(sock, (struct sockaddr*) &master, sizeof(master)) < 0) {

		panic("Could not establish connection with the master at %d", ntohs(master.sin_port));
	}

	log("Established connection with the master");
	log("Read from the master: %s", read(sock).c_str());

	value = "{ Search Key: " + value + " }";

	logVerbose("Sending: %s (%d)", value.c_str(), (int)value.length());

	int length = value.length();
	write(sock, &length, sizeof(length));

	for (int j = 0; j < value.length(); j++) {
		write(sock, &value[j], sizeof(value[j]));
	}

	std::string group = read(sock);

	log("Read group: %s from the master", group.c_str());

	return group;
}

/* Functions for interacting with the storage */

void PUT(std::string row, std::string column, std::string value) {

//	Stores a value v in column c of row r

	std::string group = findGroup(row);
	parseServerList(group);
	initializeQuorum();
	establishConnections();

	std::stringstream message;

	message << "PUT(";
	message << row << ",";
	message << column << ",";
	message << "[" << time() << "]";
	message << value << ")";

	write(message.str(), row);
	closeConnections();
}

void CPUT(std::string row, std::string column, std::string value_1, std::string value_2) {

//	Stores a value v in column c of row r

	std::string group = findGroup(row);
	parseServerList(group);
	initializeQuorum();
	establishConnections();

	std::stringstream message;

	message << "CPUT(";
	message << row << ",";
	message << column << ",";
	message << "[" << time() << "]";
	message << value_1 << "-->|<--" << value_2 << ")";

	write(message.str(), row);
	closeConnections();
}

std::string GET(std::string row, std::string column) {

//	Returns the value stored in column c of row r

	std::string group = findGroup(row);
	parseServerList(group);
	initializeQuorum();
	establishConnections();

	std::stringstream message;

	message << "GET(";
	message << row << ",";
	message << column << ")";

	write(message.str(), row);
	std::string response = read(row);
	closeConnections();
	return response;
}

void DELETE(std::string row, std::string column) {

//	Returns the value stored in column c of row r

	std::string group = findGroup(row);
	parseServerList(group);
	initializeQuorum();
	establishConnections();

	std::stringstream message;

	message << "DELETE(";
	message << row << ",";
	message << column << ")";

	write(message.str(), row);
	closeConnections();
}

void handleAdmin(int comm_fd, std::map<std::string, std::string> postParam) {

// Returns string with information for all servers
	//log("%s", "in handle admin function");
	//	Parses server list in the storage.txt configuration file and find master and then ask the master for group

	std::ifstream file(config);
	std::string contents;

	if (!file) {
		panic("An error occurred when reading %s", config.c_str());
	}

	std::string line;
	std::stringstream heartbeatIP;
	std::stringstream heartbeatPort;

	bool heartbeatFound = false;

	while (getline(file, line)) {

		if (line[0] != '#') {

			if (line.substr(line.find(", ") + 2, std::string::npos) == "Heartbeat") {

				heartbeatIP << line.substr(0, line.find(":"));
				heartbeatPort << line.substr(line.find(":") + 1, line.find(",") - line.find(":") - 1);

				logVerbose("Heartbeat found at %s:%s", heartbeatIP.str().c_str(), heartbeatPort.str().c_str());
				heartbeatFound = true;
				break;
			}
		}
	}

	if (heartbeatFound == false) {
		panic("Heartbeat was not found in the configuration file (%s)", config.c_str());
	}

//	Convert the string to the address

	struct sockaddr_in heartbeat;
	bzero(&heartbeat, sizeof(heartbeat));
	heartbeat.sin_family = AF_INET;
	int port = 0;
	heartbeatPort >> port;
	heartbeat.sin_port = htons(port);
	inet_pton(AF_INET, heartbeatIP.str().c_str(), &(heartbeat.sin_addr));

//	Connect to the heartbeat via TCP

	int sock = socket(PF_INET, SOCK_STREAM, 0);

	if(connect(sock, (struct sockaddr*) &heartbeat, sizeof(heartbeat)) < 0) {

		panic("Could not establish connection with the heartbeat at %d", ntohs(heartbeat.sin_port));
	}

	log("Established connection with the heartbeat");
	log("Read from the heartbeat: %s", read(sock).c_str());
	std::string response;

	std::string action;
	std::string server;
	if(postParam.find("action") != postParam.end()){
		action = postParam["action"];
	}

	if(action.compare("disable") == 0)
	{
		if(postParam.find("server") != postParam.end()){
			server = postParam["server"];
		}
		response = "DISABLE" + server;
		logVerbose("Sending: %s (%d)", response.c_str(), (int)response.length());

		int length = response.length();
		write(sock, &length, sizeof(length));

		for (int j = 0; j < response.length(); j++) {
			write(sock, &response[j], sizeof(response[j]));
		}
	}

	response = "ADMININFO";

	logVerbose("Sending: %s (%d)", response.c_str(), (int)response.length());

	int length = response.length();
	write(sock, &length, sizeof(length));

	for (int j = 0; j < response.length(); j++) {
		write(sock, &response[j], sizeof(response[j]));
	}

	std::string value = read(sock);

	log("Read value: %s from the heartbeat", value.c_str());

	// SPLIT value into multiple components here and generate HTML

	int delim_pos = value.find("|*|*|");
	std::string active_information = value.substr(0, delim_pos);
	value.erase(0, delim_pos+5);
	delim_pos = value.find("|*|*|");
	std::string load_information = value.substr(0, delim_pos);
	value.erase(0, delim_pos+5);
	std::string tablet_information = value;

	//log("stage 1");
	log("load %s", load_information.c_str());
	log("active %s", active_information.c_str());
	log("tablet %s", tablet_information.c_str());

	std::vector <std::string> active_tokens;
	while(active_information.find("|||") != std::string::npos)
	{
		delim_pos = active_information.find("|||");
		active_tokens.push_back(active_information.substr(0, delim_pos));
		active_information.erase(0, delim_pos+3);
	}

	for (int i=0; i<active_tokens.size(); i++)
	{
		delim_pos = active_tokens[i].find("*:*");
		std::string server_index = active_tokens[i].substr(0, delim_pos);
		active_tokens[i].erase(0, delim_pos+3);
		servertoactive[stoi(server_index)] = stoi(active_tokens[i]);
	}

	std::vector <std::string> load_tokens;
	while(load_information.find("|||") != std::string::npos)
	{
		delim_pos = load_information.find("|||");
		load_tokens.push_back(load_information.substr(0, delim_pos));
		load_information.erase(0, delim_pos+3);
	}

	for (int i=0; i<load_tokens.size(); i++)
	{
		delim_pos = load_tokens[i].find("*:*");
		std::string server_index = load_tokens[i].substr(0, delim_pos);
		load_tokens[i].erase(0, delim_pos+3);
		servertoload[stoi(server_index)] = stoi(load_tokens[i]);
	}

	std::vector <std::string> tablet_tokens;
	while(tablet_information.find("|||") != std::string::npos)
	{
		delim_pos = tablet_information.find("|||");
		tablet_tokens.push_back(tablet_information.substr(0, delim_pos));
		tablet_information.erase(0, delim_pos+3);
	}

	for (int i=0; i<tablet_tokens.size(); i++)
	{
		delim_pos = tablet_tokens[i].find("*:*");
		std::string server_index = tablet_tokens[i].substr(0, delim_pos);
		tablet_tokens[i].erase(0, delim_pos+3);
		servertotablet[stoi(server_index)] = tablet_tokens[i];
	}

	std::stringstream tablebuilder;

	tablebuilder << "<table>";
	tablebuilder << "<tr><th>Server Port</th><th>Active</th><th>Current Load</th><th>Tablet Information</th></tr>";
	std::map<int, bool>::iterator it1 = servertoactive.begin();
	while(it1 != servertoactive.end())
	{
		tablebuilder << "<tr>";
		tablebuilder << "<td>";
		tablebuilder << it1->first;
		tablebuilder << "</td>";
		tablebuilder << "<td>";
		tablebuilder << it1->second;
		tablebuilder << "</td>";
		tablebuilder << "<td>";
		tablebuilder << servertoload[it1->first];
		tablebuilder << "</td>";
		tablebuilder << "<td>";
		tablebuilder << servertotablet[it1->first];
		tablebuilder << "</td>";
		tablebuilder << "</tr>";
		it1++;
	}
	tablebuilder << "</table>";

	std::string table_string = tablebuilder.str();

	std::string body("<HTML><HEAD><TITLE>Register</TITLE></HEAD><BODY>" + table_string + "</BODY></HTML>");
	std::string headers(okHeader);

	headers = headers + "Content-Length: " + std::to_string(body.size()) + "\r\n\r\n";

	if(write(comm_fd, headers.c_str(), strlen(headers.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Register Headers\n", comm_fd);
	}
	if(write(comm_fd, body.c_str(), strlen(body.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Register Body\n", comm_fd);
	}

	if(verbose){
		std::cout << "Sending--->" << headers << body << std::endl;
	}
}

/*	Drive Functions	*/

/*	Drive assumptions:
 * 	1)	You can't have a folder and file with the same name in the same directory.
 */

std::string showMessage(std::string message) {

	if (message.substr(0, 3) == "+OK") {
		return "<div class='alert-success'>" + message + "</div>";
	}
	else {
		return "<div class='alert-danger'>" + message + "</div>";
	}
}

std::string showButtons(std::string directory) {

	/*	To be able to 'create a folder' in a directory, user should send the current directory to the server
	 * 	This function returns HTML for the create folder button along with the current directory the user is in.
	 * 	It also sends a textbox that user should fill the name of the new folder into.
	 * 	Should be called before any other drive function
	 */

	std::stringstream HTML;

	HTML << "<meta charset='UTF-8'>";
	HTML << "<link rel='stylesheet' href='Views/css/styles.css'>";

	HTML << "<div class='header clearfix'>";

	/* Current Directory */
	HTML << "<p class='directory-name'>Current directory: <i class='directory'>";
	HTML << directory;
	HTML << "</i></p>";

	/* Create Folder */
	HTML << "<div class='folder-parent'>";
	HTML << "<a class='folder create-folder'>Create Folder</a>";
	HTML << "<div class='context folder-context'>";
	HTML << "<div class='create'>";
	HTML << "<form class='create-form' action='createFolder' method='GET'>";
	HTML << "<input readonly='readonly' required name='directory' value='";
	HTML << directory;
	HTML << "' type='text'>";
	HTML << "<input class='user-input' required name='folderName' placeholder='Folder Name' type='text'>";
	HTML << "<input value='Go' class='myButton' type='submit'>";
	HTML << "</form>";
	HTML << "</div>";
	HTML << "</div>";
	HTML << "</div>";

	/* Upload File */
	HTML << "<div class='folder-parent'>";
	HTML << "<a class='folder upload-file'>Upload File</a>";
	HTML << "<div class='context folder-context'>";
	HTML << "<div class='upload'>";
	HTML << "<form class='upload-form' action='uploadFile' method='POST' enctype='multipart/form-data' accept-charset='utf-8'>";
	HTML << "<input readonly='readonly' name='directory' value='";
	HTML << directory;
	HTML << "' type='text'>";
	HTML << "<input class='user-input' required name='fileName' type='file'>";
	HTML << "<input value='Go' class='myButton' type='submit'>";
	HTML << "</form>";
	HTML << "</div>";
	HTML << "</div>";
	HTML << "</div>";

	HTML << "</div>";

	return HTML.str();
}

std::string showDirectory(std::string username, std::string directory) {

	std::stringstream html;
	std::ifstream file("Drive/directory.txt");

	/*	Instead of opening file, to be replaced with file = GET(username, "directory")	*/
	/*	Sends back the HTML which the user "username" should see when at a particular directory

	1)	Read GET("username", "directory")
	2)	Iteratively read all the folders in the root folder and add to the HTML
	3)	Iteratively read all the files in the root folder and add to the HTML */

	std::string line;
	std::string mode;

	while (getline(file, line)) {

		log("Line: %s", line.c_str());

		if (line[0] == '+') {
			mode = "folders";
		}
		else if (line[0] == '*') {
			mode = "files";
		}
		else {

			/*	Add file / folder in the HTML */

			std::stringstream folder;
			std::stringstream file;

			if (line == directory)
				/*	Current directory	*/
				continue;

			if (line.find(directory + "/") == std::string::npos)
				/*	Not a sub-folder of directory	*/
				continue;

			/*	Extract the remaining path	*/
			line = line.substr(line.find(directory + "/") + directory.length() + 1, std::string::npos);

			if (line.find("/") != std::string::npos)
				/*	Remaining path has further sub-folders	*/
				continue;

			if (mode == "folders") {
				folder << "<div class='folder-parent'>";
				folder << "<a class='folder' href='drive?action=showDirectory&directory=";
				folder << directory;
				folder << "/";
				folder << line;
				folder << "'>";
				folder << line;
				folder << "</a>";
				folder << "<div class='context folder-context'>";
				folder << "<div class='rename'>";
				folder << "<div class='rename-image'>Rename</div>";
				folder << "<form class='rename-form' action='renameFileorFolder' method=GET>";
				folder << "<input readonly='readonly' type='text' required name='directory' value='";
				folder << directory;
				folder << "'>";
				folder << "<input readonly='readonly' type='text' required name='oldName' value='";
				folder << line;
				folder << "'>";
				folder << "<input class='user-input' type='text' required name='newName' placeholder='New Name'>";
				folder << "<input type='submit' value='Go' class='myButton'>";
				folder << "</form>";
				folder << "</div>";
				folder << "<div class='delete'>";
				folder << "<div class='delete-image'>Delete</div>";
				folder << "<form class='delete-form' action='deleteFolder' method=GET>";
				folder << "<input readonly='readonly' type='text' required name='directory' value='";
				folder << directory;
				folder << "'>";
				folder << "<input readonly='readonly' type='text' required name='deleteFolder' value='";
				folder << line;
				folder << "'>";
				folder << "<p>Are you sure you want to delete this folder?</p>";
				folder << "<input type='submit' value='Delete' class='fill myButton'>";
				folder << "</form>";
				folder << "</div>";
				folder << "<div class='move'>";
				folder << "<div class='move-image'>Move</div>	";
				folder << "<form class='move-form' action='moveFileorFolder' method=GET>";
				folder << "<input readonly='readonly' type='text' required name='oldDirectory' value='";
				folder << directory;
				folder << "'>";
				folder << "<input readonly='readonly' type='text' required name='folderName' value='";
				folder << line;
				folder << "'>";
				folder << "<input type='text' class='user-input' required name='newDirectory' placeholder='Directory'>";
				folder << "<input type='submit' value='Go' class='myButton'>";
				folder << "</form>";
				folder << "</div>";
				folder << "</div>";
				folder << "</div>";

				//	logVerbose("Folder HTML: %s", folder.str().c_str());
				html << folder.str();
			}
			else if (mode == "files") {
				file << "<div class='file-parent'>";
				file << "<a class='file' href='drive?action=downloadFile&file=";
				file << directory;
				file << "/";
				file << line;
				file << "'>";
				file << line;
				file << "</a>";
				file << "<div class='context file-context'>";
				file << "<div class='rename'>";
				file << "<div class='rename-image'>Rename</div>";
				file << "<form class='rename-form' action='renameFileorFolder' method=GET>";
				file << "<input readonly='readonly' type='text' required name='directory' value='";
				file << directory;
				file << "'>";
				file << "<input readonly='readonly' type='text' required name='oldName' value='";
				file << line;
				file << "'>";
				file << "<input type='text' class='user-input' required name='newName' placeholder='New Name'>";
				file << "<input type='submit' value='Go' class='myButton'>";
				file << "</form>";
				file << "</div>";
				file << "<div class='delete'>";
				file << "<div class='delete-image'>Delete</div>";
				file << "<form class='delete-form' action='deleteFile' method=GET>";
				file << "<input readonly='readonly' type='text' required name='directory' value='";
				file << directory;
				file << "'>";
				file << "<input readonly='readonly' type='text' required name='deleteFile' value='";
				file << line;
				file << "'>";
				file << "<p>Are you sure you want to delete this file?</p>";
				file << "<input type='submit' value='Delete' class='fill myButton'>";
				file << "</form>";
				file << "</div>";
				file << "<div class='move'>";
				file << "<div class='move-image'>Move</div>	";
				file << "<form class='move-form' action='moveFileorFolder' method=GET>";
				file << "<input type='text' readonly='readonly' required name='oldDirectory' value='";
				file << directory;
				file << "'>";
				file << "<input type='text' readonly='readonly' required name='folderName' value='";
				file << line;
				file << "'>";
				file << "<input type='text' class='user-input' required name='newDirectory' placeholder='Directory'>";
				file << "<input type='submit' value='Go' class='myButton'>";
				file << "</form>";
				file << "</div>";
				file << "</div>";
				file << "</div>";

				//	logVerbose("File HTML: %s", file.str().c_str());
				html << file.str();
			}
		}
	}

	return "<div class='content-region'>" + html.str() + "</div>";
}

std::string downloadFile(std::string username, std::string filePath) {

	/*	Returns the contents of the file identified by the complete file path	*/

	std::string unique = GET(username, filePath);
	std::string contents = GET(username, unique);

	return contents;
}

std::string moveFileorFolder(std::string username, std::string oldDirectory, std::string folderName, std::string newDirectory) {

	/*	Convert ~A/B/C/X/... to ~A/X/...
	 *
	 * 	If it is a file, it will be of the form:
	 * 	~A/B/C/X.png to ~/X.png
	 */

	/*	1)	Check if the old path exists (sanity check)
	 * 	2)	Check if the new directory is actually an existing folder	*/

	/*	While we're referring it to as folderName, it might as well be a file
	 * 	Folder case is more generic and covers when it is a file	*/

	std::ifstream file("Drive/directory.txt");

	std::string line;
	std::string mode;
	bool oldPathValid = false;
	bool newPathValid = false;

	std::string oldPath = oldDirectory + "/" + folderName;
	std::string newPath = newDirectory + "/" + folderName;

	/*	Check if the old path exists (sanity check)	*/

	while (getline(file, line)) {

		if (line == oldPath) {

			oldPathValid = true;
			break;
		}
	}

	file.clear();
	file.seekg(0, std::ios::beg);

	while (getline(file, line)) {

		if (line[0] == '+') {
			mode = "folders";
		}
		else if (line[0] == '*') {
			mode = "files";
		}
		else {
			if (mode == "folders" && line == newDirectory) {

				newPathValid = true;
				break;
			}
		}
	}

	std::stringstream message;

	if (!(oldPathValid && newPathValid)) {
		message << "-ERR: Move operation failed. Either " << oldPath << " or " << newDirectory << "is not valid.";
		logVerbose("%s", message.str().c_str());
		return message.str();
	}

	file.clear();
	file.seekg(0, std::ios::beg);

	std::stringstream buffer;

	/*	Both of the paths are valid	*/

	while (getline(file, line)) {

		if (line[0] == '+') {
			mode = "folders";

			logVerbose("Saving %s", line.c_str());
			buffer << line << "\n";
		}
		else if (line[0] == '*') {
			mode = "files";

			logVerbose("Saving %s", line.c_str());
			buffer << line << "\n";
		}
		else {
			if (line.substr(0, oldPath.length()) == oldPath) {

				if (mode == "files") {
					std::string originalPath = line;
					std::string renamedPath = line.replace(0, oldPath.length(), newPath);
					buffer << renamedPath << "\n";

					logVerbose("Replaced %s with %s", originalPath.c_str(), renamedPath.c_str());

					/*	Change <USER, OLD FILEPATH, UNIQUE FILE ID> to
					 * 	<USER, NEW FILEPATH, UNIQUE FILE ID>
					 * 	No change to the actual file <USER, UNIQUE FILE ID, FILE CONTENTS>	*/

					std::string unique = GET(username, originalPath);
					PUT(username, renamedPath, unique);
					DELETE(username, originalPath);
				}
				else if (mode == "folders") {
					std::string originalPath = line;
					std::string renamedPath = line.replace(0, oldPath.length(), newPath);
					buffer << renamedPath << "\n";

					logVerbose("Replaced %s with %s", originalPath.c_str(), renamedPath.c_str());
				}
			}
			else {
				logVerbose("Saving %s", line.c_str());
				buffer << line << "\n";
			}
		}
	}

	std::ofstream out("Drive/directory.txt");
	out << buffer.str();
	out.close();

	message << "+OK: Moved " << folderName << " from " << folderName << " to " << newDirectory << ".";
	logVerbose("%s", message.str().c_str());
	return message.str();
}

std::string renameFileorFolder(std::string username, std::string directory, std::string oldName, std::string newName) {

	/*	Convert ~directory/X/path to ~directory/Y/path
	 *
	 * 	If it is a file, it will be of the form:
	 * 	~directory/X.png to ~directory/Y.png
	 * 	in which case, we'll just be replacing the occurrence of the former string with the latter string
	 *
	 * 	If it is a folder, just rename in the directory.
	 * 	If it is a file, also rename in the storage.
	 */

	std::string oldPath = directory + "/" + oldName;
	std::string newPath = directory + "/" + newName;
	std::ifstream file("Drive/directory.txt");
	bool foundFileorFolder = false;
	std::string line;
	std::string mode;

	std::stringstream buffer;
	std::stringstream message;

	if (newName.find('/') != std::string::npos) {
		message << "-ERR: Cannot rename " << oldName.c_str() << " to " << newName.c_str() << ", which is a directory";
		logVerbose("%s", message.str().c_str());
		return message.str();
	}

	while (getline(file, line)) {

		if (line[0] == '+') {
			mode = "folders";

			logVerbose("Saving %s", line.c_str());
			buffer << line << "\n";
		}
		else if (line[0] == '*') {
			mode = "files";

			logVerbose("Saving %s", line.c_str());
			buffer << line << "\n";
		}
		else {
			if (line.substr(0, oldPath.length()) == oldPath) {

				foundFileorFolder = true;

				if (mode == "files") {
					std::string originalPath = line;
					std::string renamedPath = line.replace(0, oldPath.length(), newPath);
					buffer << renamedPath << "\n";

					logVerbose("Replaced %s with %s", originalPath.c_str(), renamedPath.c_str());

					/*	Change <USER, OLD FILEPATH, UNIQUE FILE ID> to
					 * 	<USER, NEW FILEPATH, UNIQUE FILE ID>
					 * 	No change to the actual file <USER, UNIQUE FILE ID, FILE CONTENTS>	*/

					std::string unique = GET(username, originalPath);
					PUT(username, renamedPath, unique);
					DELETE(username, originalPath);
				}
				else if (mode == "folders") {
					std::string originalPath = line;
					std::string renamedPath = line.replace(0, oldPath.length(), newPath);
					buffer << renamedPath << "\n";

					logVerbose("Replaced %s with %s", originalPath.c_str(), renamedPath.c_str());
				}
			}
			else {
				logVerbose("Saving %s", line.c_str());
				buffer << line << "\n";
			}
		}
	}

	std::ofstream out("Drive/directory.txt");
	out << buffer.str();
	out.close();

	if (foundFileorFolder == false) {
		message << "-ERR: Could not find " << oldPath.c_str() << ". Rename operation failed";
		logVerbose("%s", message.str().c_str());
		return message.str();
	}
	else {
		message << "+OK: Renamed " << oldName.c_str() << " to " << newName.c_str() << ".";
		logVerbose("%s", message.str().c_str());
		return message.str();
	}
}

std::string deleteFolder(std::string username, std::string directory, std::string folderName) {

	/*	Delete folder 'folderName' from 'directory' for user 'username'	*/

	/*	TODO:
	 * 	Recursively delete all the files and sub folders in that folder
	 * 	For deleting files:	DELETE(username, file)
	 * 	For deleting folders: Just update the directory file (GET(username, directory)
	 */

	/*	1)	Check if folder exists in the directory listing and delete it	*/

	std::ifstream file("Drive/directory.txt");
	std::stringstream buffer;

	std::string line;
	bool folderExists = false;

	std::string mode;

	std::string path = directory + "/" + folderName;

	while (getline(file, line)) {

		if (line[0] == '+') {
			mode = "folders";
			buffer << line << "\n";
		}
		else if (line[0] == '*') {
			mode = "files";
			buffer << line << "\n";
		}
		else {

			if (line == path) {
				folderExists = true;
				logVerbose("Deleting %s", line.c_str());
				continue;
			}
			else if (line.substr(0, path.length()) == path) {

				if (mode == "files") {
					logVerbose("Deleting file %s", line.c_str());

//					std::string unique = GET(username, path);
//					DELETE(username, unique);
//					DELETE(username, path);
				}
				else if (mode == "folders") {
					logVerbose("Deleting folder %s", line.c_str());
				}
			}
			else if (line != "" && line != "\n"){

				/*	Empty lines are deleted	(Well, this block only keeps the non-empty lines	*/
				logSuccess("Saving %s", line.c_str());
				buffer << line << "\n";
			}
		}
	}

	std::ofstream out("Drive/directory.txt");
	out << buffer.str();
	out.close();

	std::stringstream message;

	if (folderExists == false) {
		logVerbose("Could not find %s. Folder deletion failed.", (directory + "/" + folderName).c_str());

		message << "-ERR: Could not find " << directory << "/" << folderName << ". Folder deletion failed.";
		logVerbose("%s", message.str().c_str());
		return message.str();
	}
	else {
		message << "+OK: Deleted " << directory << "/" << folderName << ".";
		logVerbose("%s", message.str().c_str());
		return message.str();
	}
}

std::string deleteFile(std::string username, std::string directory, std::string fileName) {

	/*	1)	Check if file exists in the directory listing and delete it	*/

	std::ifstream file("Drive/directory.txt");
	std::stringstream buffer;

	std::string line;
	bool fileExists = false;

	while (getline(file, line)) {

		if (line == (directory + "/" + fileName)) {
			fileExists = true;
		}
		else if (line != "" && line != "\n"){
			buffer << line << "\n";
		}
	}

	std::ofstream out("Drive/directory.txt");
	out << buffer.str();
	out.close();

	std::stringstream message;

	if (fileExists == false) {
		message << "-ERR: Could not find " << directory << "/" << fileName << ". File deletion failed.";
		logVerbose("%s", message.str().c_str());
		return message.str();
	}
	else {
		std::string unique = GET(username, (directory + "/" + fileName));
		DELETE(username, unique);
		DELETE(username, (directory + "/" + fileName));
	}

	message << "+OK: Deleted " << directory << "/" << fileName << ".";
	logVerbose("%s", message.str().c_str());
	return message.str();
}

std::string createFolder(std::string username, std::string directory, std::string folderName) {

	/*	Creates folder 'foldername' in 'directory' for user 'username'	*/
	/*	Instead of opening file, to be replaced with file = GET(username, "directory")	*/

	std::ifstream file("Drive/directory.txt");
	std::stringstream message;

	std::string line;
	bool directoryExists = false;

	while (getline(file, line)) {

		if (line == directory) {

			/*	Check if the directory, that the user wants to create the folder in, exists	*/
			directoryExists = true;
			break;
		}
	}

	file.clear();
	file.seekg(0, std::ios::beg);

	while (getline(file, line)) {

		if (line == directory + "/" + folderName) {

			/*	Check in case the folder already exists	*/
			message << "-ERR: The folder " << line.c_str() << " already exists. Folder creation failed.";
			logVerbose("%s", message.str().c_str());
			return message.str();
		}
	}

	if (directoryExists == false) {
		message << "-ERR: The directory " << directory.c_str() << " already exists. Folder creation failed.";
		logVerbose("%s", message.str().c_str());
		return message.str();
	}

	/*	The directory was found and the folder is not already there	*/

	std::ofstream append("Drive/directory.txt", std::ios_base::app | std::ios_base::out);
	append << "\n+Folders\n";
	append << directory + "/" + folderName;

	append.close();
	logVerbose("Folder %s created in %s", folderName.c_str(), directory.c_str());

	message << "+OK: Folder " << folderName.c_str() << " created in " << directory.c_str() << ".";
	logVerbose("%s", message.str().c_str());
	return message.str();
}

void uploadFile(std::string username, std::string directory, std::string fileName, std::string fileContents) {

	/*	Uploads file 'fileName' in the 'drectory', both in the directory file and the storage (key - value)
	 * 	Stores in the form of <FILENAME, Unique ID> and another record <Unique ID, File Contents>	*/

	/*	1)	Add the file to the directory	*/

	std::ifstream file("Drive/directory.txt");
	std::string line;
	bool directoryExists = false;

	while (getline(file, line)) {

		if (line == directory) {

			/*	Check if the directory, that the user wants to upload the file in, exists	*/
			directoryExists = true;
			break;
		}
	}

	file.clear();
	file.seekg(0, std::ios::beg);

	while (getline(file, line)) {

		if (line == directory + "/" + fileName) {

			/*	Check in case the file already exists	*/
			logVerbose("The file already exists (%s). File upload failed", line.c_str());
			return;
		}
	}

	if (directoryExists == false) {
		logVerbose("Given directory, %s does not exist. File upload failed", directory.c_str());
		return;
	}

	/*	The directory was found and the file is not already there	*/

	std::ofstream append("Drive/directory.txt", std::ios_base::app | std::ios_base::out);
	append << "\n*Files\n";
	append << directory + "/" + fileName;

	append.close();
	logVerbose("File %s uploaded in %s", fileName.c_str(), directory.c_str());

	/*	2)	Since Step 1) passed, add this as a key value pair	*/

	std::string unique = time();
	PUT(username, directory + "/" + fileName, unique);
	PUT(username, unique, fileContents);
}

/*	Drive functions end	*/

//Handle files differently????
void handleDrive(int comm_fd, std::string username, std::map<std::string, std::string> postParam){

	//Default is to show directory
	std::string action("showDirectory");
	if(postParam.find("action") != postParam.end()){
		action = postParam["action"];
	}

	if(action.compare("showDirectory") == 0){
		std::string body("<!DOCTYPE html><html><head><title>PennCloud</title></head><body><h1>Welcome to PennCloud</h1>");
		std::string headers(okHeader);

		//Default look for root directory, else look for the one specified in the params
		std::string directory("root");
		if(postParam.find("directory") != postParam.end()){
			directory = postParam["directory"];
		}
		body = body + showButtons(directory); //TODO verify this!!

		std::string content = showDirectory(username, directory);
		body = body + content + "</body></html>";
		headers = headers + "Content-Length: " + std::to_string(body.size()) + "\r\n\r\n";
		//Send main headers, then content-length header, then the content

		if(write(comm_fd, headers.c_str(), strlen(headers.c_str())) <= 0){
			fprintf(stderr, "%d Thread Couldn't Write Headers\n", comm_fd);
		}
		if(write(comm_fd, body.c_str(), strlen(body.c_str())) <= 0){
			fprintf(stderr, "%d Thread Couldn't Write Body\n", comm_fd);
		}
		if(verbose){
			std::cout << "Sending --> " << headers << body << std::endl;
		}

	} else if(action.compare("downloadFile") == 0){
		std::string filePath = postParam["file"];
		std::string content = downloadFile(username, filePath);
		std::string downloadHeader("HTTP/1.1 200 OK\r\nServer: 505Team11\r\nConnection: close\r\n");

		//Add the content-type header
		if(filePath.find(".png") != std::string::npos){
			downloadHeader = downloadHeader + "Content-Type: image/png\r\n";
		} else if(filePath.find(".txt") != std::string::npos){
			downloadHeader = downloadHeader + "Content-Type: text/plain\r\n";
		} else if(filePath.find(".pdf") != std::string::npos){
			downloadHeader = downloadHeader + "Content-Type: application/pdf\r\n";
		} else {
			//TODO verify the default content-type
			downloadHeader = downloadHeader + "Content-Type: text/html\r\n";
		}
		//Add the content-length header
		downloadHeader = downloadHeader + "Content-Length: " + std::to_string(content.size()) + "\r\n\r\n";

		if(write(comm_fd, downloadHeader.c_str(), strlen(downloadHeader.c_str())) <= 0){
			fprintf(stderr, "%d Thread Couldn't Write Headers\n", comm_fd);
		}
		if(write(comm_fd, content.c_str(), strlen(content.c_str())) <= 0){
			fprintf(stderr, "%d Thread Couldn't Write Body\n", comm_fd);
		}
		if(verbose){
			std::cout << "Sending Header--> " << downloadHeader << std::endl;
		}

	} else {
		printf("######## SHOULDN'T BE HERE!!!!!\n");
		//TODO decide what to do here
	}
}

/*
 * Helper Methods
 */

std::string getCookieHeader(std::string username){
	std::string cookieHeader("Set-Cookie: ");
	cookieHeader = cookieHeader + username + "\r\n";
	return cookieHeader;
}

std::string urlDecoder(std::string url){
	return  std::regex_replace(url, std::regex("%2F"), "/");
}

void redirectToLogin(int comm_fd){
	std::string headers("HTTP/1.1 302 Found\r\nLocation: /login\r\nServer: 505Team11\r\nContent-Type: text/html\r\nConnection: close\r\n\r\n");

	if(write(comm_fd, headers.c_str(), strlen(headers.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Headers\n", comm_fd);
	}
	if(verbose){
		std::cout << headers << std::endl;
	}
}

void send404(int comm_fd){
	std::string headers("HTTP/1.1 404 Not Found\r\nServer: 505Team11\r\nContent-Type: text/html\r\nConnection: close\r\n\r\n");

	if(write(comm_fd, headers.c_str(), strlen(headers.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Headers\n", comm_fd);
	}
	if(verbose){
		std::cout << headers << std::endl;
	}
}

/**
 * For each of the Main Pages, get the default headers, determine body, compute Content-length header and then send
 */
void sendLoginPage(int comm_fd){
	std::string body("<HTML><HEAD><TITLE>Login</TITLE></HEAD><BODY><form action=\"login\" method = \"post\">Username:<br><input type=\"text\" name=\"username\"><br>Password:<br><input type=\"text\" name=\"password\"><br><br><input type=\"submit\" value=\"Submit\"></form></BODY></HTML>");
	std::string headers(okHeader);

	headers = headers + "Content-Length: " + std::to_string(body.size()) + "\r\n\r\n";

	if(write(comm_fd, headers.c_str(), strlen(headers.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Register Headers\n", comm_fd);
	}
	if(write(comm_fd, body.c_str(), strlen(body.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Register Body\n", comm_fd);
	}

	if(verbose){
		std::cout << "Sending--->" << headers << body << std::endl;
	}

}

void sendRegisterPage(int comm_fd){
	std::string body("<HTML><HEAD><TITLE>Register</TITLE></HEAD><BODY><form action=\"register\" method = \"post\">Username:<br><input type=\"text\" name=\"username\"><br>Password:<br><input type=\"text\" name=\"password\"><br><br><input type=\"submit\" value=\"Submit\"></form></BODY></HTML>");
	std::string headers(okHeader);

	headers = headers + "Content-Length: " + std::to_string(body.size()) + "\r\n\r\n";

	if(write(comm_fd, headers.c_str(), strlen(headers.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Register Headers\n", comm_fd);
	}
	if(write(comm_fd, body.c_str(), strlen(body.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Register Body\n", comm_fd);
	}

	if(verbose){
		std::cout << "Sending--->" << headers << body << std::endl;
	}

}


void sendMainPage(int comm_fd, std::string cookieHeader){
	std::string body("<!DOCTYPE html><html><head><title>PennCloud</title></head><body><h1>Welcome to PennCloud</h1>");
	std::string headers(okHeader);

	body =  body + "Access your <a href=\"/email\">email</a> or <a href=\"/drive\">drive</a>";
	body = body + "</body></html>";

	headers = headers + cookieHeader + "Content-Length: " + std::to_string(body.size()) + "\r\n\r\n";

	if(write(comm_fd, headers.c_str(), strlen(headers.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Headers\n", comm_fd);
	}

	if(write(comm_fd, body.c_str(), strlen(body.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Body\n", comm_fd);
	}

	if(verbose){
		std::cout << "Sending--->" << headers << body << std::endl;
	}

}

//TODO need to get a string from each of the drive methods

void handleDeleteFolder(int comm_fd, std::string username, std::map<std::string, std::string> postParam){
	std::string directory = postParam["directory"];
	std::string folder = postParam["deleteFolder"];
	std::string message;

	message = deleteFolder(username, directory, folder);

	//TODO this is duplicate. See if you can condense it all!
	std::string body("<!DOCTYPE html><html><head><title>PennCloud</title></head><body><h1>Welcome to PennCloud</h1>");
	std::string headers(okHeader);

	//Default look for root directory, else look for the one specified in the params
	body += showMessage(message);
	body = body + showButtons(directory); //TODO verify this!!

	std::string content = showDirectory(username, directory);
	body = body + content + "</body></html>";
	headers = headers + "Content-Length: " + std::to_string(body.size()) + "\r\n\r\n";
	//Send main headers, then content-length header, then the content

	if(write(comm_fd, headers.c_str(), strlen(headers.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Headers\n", comm_fd);
	}
	if(write(comm_fd, body.c_str(), strlen(body.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Body\n", comm_fd);
	}
	if(verbose){
		std::cout << "Sending --> " << headers << body << std::endl;
	}

}

void handleDeleteFile(int comm_fd, std::string username, std::map<std::string, std::string> postParam){
	std::string directory = postParam["directory"];
	std::string file = postParam["deleteFile"];

	deleteFile(username, directory, file);

	//TODO this is duplicate. See if you can condense it all!
	std::string body("<!DOCTYPE html><html><head><title>PennCloud</title></head><body><h1>Welcome to PennCloud</h1>");
	std::string headers(okHeader);

	//Default look for root directory, else look for the one specified in the params
	body = body + showButtons("root"); //TODO verify this!!

	std::string content = showDirectory(username, "root");
	body = body + content + "</body></html>";
	headers = headers + "Content-Length: " + std::to_string(body.size()) + "\r\n\r\n";
	//Send main headers, then content-length header, then the content

	if(write(comm_fd, headers.c_str(), strlen(headers.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Headers\n", comm_fd);
	}
	if(write(comm_fd, body.c_str(), strlen(body.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Body\n", comm_fd);
	}
	if(verbose){
		std::cout << "Sending --> " << headers << body << std::endl;
	}

}

void handleMoveFileorFolder(int comm_fd, std::string username, std::map<std::string, std::string> postParam){
	std::string oldDirectory = postParam["oldDirectory"];
	std::string folderName = postParam["folderName"];
	std::string newDirectory = postParam["newDirectory"];

	moveFileorFolder(username, oldDirectory, folderName, newDirectory);
	std::string body("<!DOCTYPE html><html><head><title>PennCloud</title></head><body><h1>Welcome to PennCloud</h1>");
	std::string headers(okHeader);

	//Default look for root directory, else look for the one specified in the params
	body = body + showButtons("root"); //TODO verify this!!

	std::string content = showDirectory(username, "root");
	body = body + content + "</body></html>";
	headers = headers + "Content-Length: " + std::to_string(body.size()) + "\r\n\r\n";
	//Send main headers, then content-length header, then the content

	if(write(comm_fd, headers.c_str(), strlen(headers.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Headers\n", comm_fd);
	}
	if(write(comm_fd, body.c_str(), strlen(body.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Body\n", comm_fd);
	}
	if(verbose){
		std::cout << "Sending --> " << headers << body << std::endl;
	}

}

void handleRenameFileorFolder(int comm_fd, std::string username, std::map<std::string, std::string> postParam){
	std::string directory = postParam["directory"];
	std::string oldName = postParam["oldName"];
	std::string newName = postParam["newName"];
	std::string message;

	message = renameFileorFolder(username, directory, oldName, newName);
	std::string body("<!DOCTYPE html><html><head><title>PennCloud</title></head><body><h1>Welcome to PennCloud</h1>");
	std::string headers(okHeader);

	//Default look for root directory, else look for the one specified in the params
	body += showMessage(message);
	body = body + showButtons(directory); //TODO verify this!!

	std::string content = showDirectory(username, directory);
	body = body + content + "</body></html>";
	headers = headers + "Content-Length: " + std::to_string(body.size()) + "\r\n\r\n";
	//Send main headers, then content-length header, then the content

	if(write(comm_fd, headers.c_str(), strlen(headers.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Headers\n", comm_fd);
	}
	if(write(comm_fd, body.c_str(), strlen(body.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Body\n", comm_fd);
	}
	if(verbose){
		std::cout << "Sending --> " << headers << body << std::endl;
	}
}


void handleCreateFolder(int comm_fd, std::string username, std::map<std::string, std::string> postParam){
	std::string folderName = postParam["folderName"];
	std::string directory = postParam["directory"];
	std::string message;

	std::cout << "FolderName: " << folderName << " directory: " << directory << std::endl;
	message = createFolder(username, directory, folderName);

	std::string body("<!DOCTYPE html><html><head><title>PennCloud</title></head><body><h1>Welcome to PennCloud</h1>");
	std::string headers(okHeader);

	//Default look for root directory, else look for the one specified in the params
	body += showMessage(message);
	body = body + showButtons(directory); //TODO verify this!!

	std::string content = showDirectory(username, directory);
	body = body + content + "</body></html>";
	headers = headers + "Content-Length: " + std::to_string(body.size()) + "\r\n\r\n";
	//Send main headers, then content-length header, then the content

	if(write(comm_fd, headers.c_str(), strlen(headers.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Headers\n", comm_fd);
	}
	if(write(comm_fd, body.c_str(), strlen(body.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Body\n", comm_fd);
	}
	if(verbose){
		std::cout << "Sending --> " << headers << body << std::endl;
	}
}

void handleUploadFile(int comm_fd, std::string username, std::map<std::string, std::string> postParam){
	//TODO need fileContent but currently not getting!
	//Not sure what is getting returned, so printing out everything that's got till now
}


/*
 * This method provides the css and svg files required for styling
 */
void handleViews(int comm_fd, std::string path){
	std::ifstream ifs(path);

	// If the file is not found then return a 404 error
	if(!ifs.good()){
		send404(comm_fd);
		return;
	}
	std::string body((std::istreambuf_iterator<char>(ifs)),
	                       std::istreambuf_iterator<char>());
	std::string headers("HTTP/1.1 200 OK\r\nServer: 505Team11\r\nConnection: close\r\n");

	if(path.find("svg") != std::string::npos){
		headers = headers + "Content-Type: image/svg+xml\r\n";
	} else {
		headers = headers + "Content-Type: text/css\r\n";
	}

	headers = headers + "Content-Length: " + std::to_string(body.size()) + "\r\n\r\n";

	if(write(comm_fd, headers.c_str(), strlen(headers.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Register Headers\n", comm_fd);
	}
	if(write(comm_fd, body.c_str(), strlen(body.c_str())) <= 0){
		fprintf(stderr, "%d Thread Couldn't Write Register Body\n", comm_fd);
	}

	if(verbose){
		std::cout << "Sending--->" << headers << body << std::endl;
	}
}


void *worker(void *arg){
	int comm_fd = *(int*)arg;
	char buf[1000] = {'\0'};
	int bytesRead = read(comm_fd, buf, 1000); // TODO: check
	std::map<std::string, std::string> postParam; // TO-HANDLE if implementing persistent connection, then handle this

	if(bytesRead <= 0){
		fprintf(stderr, "%d Thread Couldn't Read\n", comm_fd);
		pthread_exit(NULL);
	}
	if(verbose){
		fprintf(stderr, "[%d] C: %s", comm_fd, buf);
	}

	std::string request(buf);
	std::string headDelim = "\r\n\r\n";
	std::string lineDelim = "\r\n";
	std::string spaceDelim = " ";
	std::string quesDelim = "?";
	std::string cookieDelim = "Cookie: ";
	std::string username("none");

	int startOfBody = request.find(headDelim);
	std::string headers = request.substr(0, startOfBody);
	std::string body = request.substr(startOfBody+1, request.size());


	int startOfLine = headers.find(lineDelim);
	std::string firstLine = headers.substr(0, startOfLine);

	int startOfSpace = firstLine.find(spaceDelim);
	std::string method = firstLine.substr(0, startOfSpace);
	std::string path = firstLine.substr(startOfSpace + 1);
	path = path.substr(0, path.find(spaceDelim));

	std::cout << "Headers: " << headers << std::endl;
	std::cout << "Body: " << body << std::endl;
	std::cout << "Method: " << method << std::endl;
	std::cout << "Path: " << path << std::endl;

	//Get the username from the cookie
	int startOfCookie = headers.find(cookieDelim);
	if(startOfCookie != -1){
		std::string cookieHeader = headers.substr(startOfCookie + 8); //Want to match after the word Cookie:
		//std::cout << "Cookie Header: " << cookieHeader << std::endl;
		startOfLine = cookieHeader.find(lineDelim);
		username = cookieHeader.substr(0, startOfLine);
		std::cout << "Got username: " << username << std::endl;
	}

	//Split the parameters in the GET request
	int startOfParam = path.find(quesDelim);
	if(startOfParam != -1){
		std::string params = path.substr(startOfParam + 1);
		path = path.substr(0, startOfParam);
		int pairStart = 0;
		std::string key, value;
		do{
			pairStart = params.find('&');
			std::string pair = params.substr(0, pairStart);
			params = params.substr(pairStart+1);

			int valStart = pair.find("=");
			key = pair.substr(0, valStart);
			value = pair.substr(valStart + 1);

			// Decode the URL
			// i)Replace %2F with /
			value = urlDecoder(value);

			std::cout << "key: " << key << " value: " << value << std::endl;
			postParam[key] = value;
		} while (pairStart != -1);

	}

	std::cout << "New Path: " << path << std::endl;

	if(method.compare("GET") == 0){
		printf("It's a GET request\n");
		if(path.compare("/login") == 0 || path.compare("/login/") == 0){
			sendLoginPage(comm_fd);
		} else if(path.compare("/register") == 0 || path.compare("/register/") == 0){
			sendRegisterPage(comm_fd);
		} else if(path.compare("/admin") == 0 || path.compare("/admin/") == 0) {
			handleAdmin(comm_fd, postParam);
		} else if(path.compare("/drive") == 0 || path.compare("/drive/") == 0){
			if(username.compare("none") == 0){
				redirectToLogin(comm_fd);
			} else {
				handleDrive(comm_fd, username, postParam);
			}
		} else if(path.compare("/mail") == 0 || path.compare("/mail/") == 0){
			if(username.compare("none") == 0){
				redirectToLogin(comm_fd);
			} else {
				sendMainPage(comm_fd, "");
			}
		} else if(path.compare("/deleteFile") == 0 || path.compare("/deleteFile/") == 0){
			if(username.compare("none") == 0){
				redirectToLogin(comm_fd);
			} else {
				handleDeleteFile(comm_fd, username, postParam);
			}
		} else if(path.compare("/deleteFolder") == 0 || path.compare("/deleteFolder/") == 0){
			if(username.compare("none") == 0){
				redirectToLogin(comm_fd);
			} else {
				handleDeleteFolder(comm_fd, username, postParam);
			}
		} else if(path.compare("/moveFileorFolder") == 0 || path.compare("/moveFileorFolder/") == 0){
			if(username.compare("none") == 0){
				redirectToLogin(comm_fd);
			} else {
				handleMoveFileorFolder(comm_fd, username, postParam);
			}
		} else if(path.compare("/renameFileorFolder") == 0 || path.compare("/renameFileorFolder/") == 0){
			if(username.compare("none") == 0){
				redirectToLogin(comm_fd);
			} else {
				handleRenameFileorFolder(comm_fd, username, postParam);
			}
		} else if(path.compare("/createFolder") == 0 || path.compare("/createFolder/") == 0){
			if(username.compare("none") == 0){
				redirectToLogin(comm_fd);
			} else {
				handleCreateFolder(comm_fd, username, postParam);
			}
		} else if(path.find("/Views") != std::string::npos){
			handleViews(comm_fd, "." + path);
		} else {
			//TODO decide what would be the default
			printf("######## Some unknown path for GET method!! \n");
			sendMainPage(comm_fd, "");
		}
	} else if (method.compare("POST") == 0){
		printf("It's a POST request\n");

		//Split the parameters in the body
		int pairStart = 0;
		std::string key, value;
		if(path.compare("/uploadFile") == 0){
			if(username.compare("none") == 0){
				redirectToLogin(comm_fd);
			} else {
				std::string boundaryDelim("boundary=");
				std::string boundary("none");

				//Get the boundary from the header
				int startOfBoundary = headers.find(boundaryDelim);
				if(startOfBoundary != -1){
					std::string boundaryHeader = headers.substr(startOfBoundary + 9);
					//std::cout << "Boundary Header: " << boundaryHeader << std::endl;
					startOfLine = boundaryHeader.find(lineDelim);
					boundary = "--" + boundaryHeader.substr(0, startOfLine); //TODO Verify with TA!!
					std::cout << "Got boundary: " << boundary << std::endl;
				} else {
					printf("ERROR! Boundary not found for Upload File\n");
				}
				//TODO Process the body for upload file
				size_t pos = 0;
				std::string bodyCopy(body);
				std::string part;
				std::string filenameDelim("filename=");
				std::string deirectoryDelim("directory=");

				int i = 1;
				while ((pos = bodyCopy.find(boundary)) != std::string::npos) {
				    part = bodyCopy.substr(0, pos);
				    std::cout << "i: " << i++ << part << std::endl;
				    bodyCopy.erase(0, pos + boundary.length());

				    // Find the pos of filename and the contents
				    if((pos = part.find(filenameDelim)) != std::string::npos){
						std::string fileStr = part.substr(pos + filenameDelim.length());
						std::string contentStr = part.substr(pos);

						//Get the filename
						startOfLine = fileStr.find(lineDelim);
				    	std::string fileName;
				    	fileName = fileStr.substr(0, startOfLine);
				    	//Remove the double quotes around the filename
				    	fileName.erase(remove( fileName.begin(), fileName.end(), '\"' ),fileName.end());
				    	postParam["fileName"] = fileName;
				    	std::cout << "FileName: " << postParam["fileName"] << std::endl;

				    	//Get the contents
				    	startOfBody = contentStr.find(headDelim);
				    	postParam["contents"] = contentStr.substr(startOfBody + headDelim.length());
				    	std::cout << "Contents: " << postParam["contents"] << std::endl;
				    }
				}
				if(bodyCopy.length() > 5){ //TODO verify with TA
					std::cout << "End of body: " << bodyCopy << std::endl;
				}
				handleUploadFile(comm_fd, username, postParam);
			}
		} else {
			// Strip space from body
			body.erase(remove_if(body.begin(), body.end(), isspace), body.end());
			do{
				pairStart = body.find('&');
				std::string pair = body.substr(0, pairStart);
				body = body.substr(pairStart+1);

				int valStart = pair.find("=");
				key = pair.substr(0, valStart);
				value = pair.substr(valStart + 1);
				std::cout << "key: " << key << " value: " << value << std::endl;
				postParam[key] = value;
			} while (pairStart != -1);

			if(path.compare("/register") == 0){
				std::string cookieUsername = getCookieHeader(postParam["username"]);
				sendMainPage(comm_fd, cookieUsername);
			} else if(path.compare("/login") == 0){
				std::string cookieUsername = getCookieHeader(postParam["username"]);
				sendMainPage(comm_fd, cookieUsername);
			} else {
				//TODO decide how to handle
				printf("##### Some unknown path for POST!!! \n");
			}
		} // Not Upload file

	} else {
		printf("Unknown HTTP Method\n");
	}

	close(comm_fd);
	pthread_exit(NULL);
}



int main(int argc, char *argv[])
{
	/*	The following three lines are important
	 * 	Most of the stuff will break / not work if these are removed
	 */

	config = std::string(argv[1]);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGINT, terminate);

	/*	Also important	*/
	logSuccess("Om Shree Ganeshaya Namaha!\n");

	/*	Important lines end	*/


  int c;

	//Check for optional arguments
	while ((c = getopt(argc, argv, "p:v")) != -1) {
		switch (c) {
		case 'p':
			portNum = atoi(optarg);
			break;
		case 'v':
			verbose = true;
			break;
		case '?':
			break;
			printf("Usage -v for verbose and -p for port number\n");
			exit(1);
		}
	}

	//Create and bind the server socket
	int listen_fd = socket(PF_INET, SOCK_STREAM, 0);
	if (listen_fd < 0) {
		fprintf(stderr, "Couldn't open socket\n");
		exit(1);
	}
	struct sockaddr_in servaddr;
	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htons(INADDR_ANY );
	servaddr.sin_port = htons(portNum);
	if (bind(listen_fd, (struct sockaddr*) &servaddr, sizeof(servaddr)) < 0) {
		fprintf(stderr, "Couldn't Bind to %d\n", ntohs(portNum));
		exit(1);
	}
	if (listen(listen_fd, 100) < 0) {
		fprintf(stderr, "Couldn't Listen\n");
		exit(1);
	}
	while (true) {
		struct sockaddr_in clientaddr;
		socklen_t clientaddrlen = sizeof(clientaddr);
		int *fd = (int*) malloc(sizeof(int));
		*fd = accept(listen_fd, (struct sockaddr*) &clientaddr, &clientaddrlen);
		if (*fd < 0) {
			fprintf(stderr, "Couldn't Accept\n");
			exit(1);
		}
		if (verbose)
			fprintf(stderr, "[%d] New Connection\n", *fd);

		pthread_t thread;
		pthread_create(&thread, NULL, worker, fd);
	}

	return 0;
}
